<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Attend Examination</title>
  <style>
    .opt.selected {
      background-color: #c8e6c9;
    }
    .navbar a, .officialsection a {
      margin-right: 1em;
    }
    #timer {
      font-size: 1.2em;
      margin-bottom: 0.5em;
      color: #c62828;
    }
  </style>
</head>
<body>
  <div class="navbar">
    <a href="{% url 'dashboard' email=email %}">DASHBOARD</a>
    <a href="{% url 'post'      email=email %}">POST</a>
    <a href="{% url 'chat'      email=email %}">CHAT</a>
    <a href="{% url 'official'  email=email %}">OFFICIAL</a>
    <a href="/profile">PROFILE</a>
    <a href="{% url 'logout'    email=email %}">LOGOUT</a>
  </div>

  <div class="officialsection">
    <a href="{% url 'createexam' email=email %}">CREATE EXAMINATION</a>
    <a href="{% url 'attendexam' email=email %}">ATTEND EXAMINATION</a>
    <a href="{% url 'liveleaderboard' email=email%}">VIEW LIVE LEADERBOARD FOR EXAM</a>
  </div>

  <div class="exampanel">
    <form id="verifyExam">
      <input
        type="number"
        name="examid"
        id="examid"
        placeholder="Enter the examination id"
        required
      />
      <input type="submit" value="Verify" />
    </form>
  </div>

  <script>
    // CSRF helper
    function getCookie(name) {
      let v = null;
      if (document.cookie && document.cookie !== "") {
        document.cookie.split(";").forEach(c => {
          c = c.trim();
          if (c.startsWith(name + "=")) {
            v = decodeURIComponent(c.slice(name.length + 1));
          }
        });
      }
      return v;
    }
    const csrftoken = getCookie("csrftoken") || "";

    // sessionStorage key
    const STATE_KEY = "attendExamState";
    function persistState(s) { sessionStorage.setItem(STATE_KEY, JSON.stringify(s)); }
    function restoreState() { const j = sessionStorage.getItem(STATE_KEY); return j?JSON.parse(j):null; }
    function clearState() { sessionStorage.removeItem(STATE_KEY); }

    // show message in panel
    function showMessage(msg) {
      document.querySelector(".exampanel").innerHTML = `<h3>${msg}</h3>`;
    }

    // countdown until start
    function showCountdown(startDate, onStart) {
      const panel = document.querySelector(".exampanel");
      panel.innerHTML = `<h3>Exam starts in <span id="countdown"></span></h3>`;
      const iv = setInterval(() => {
        const diff = startDate - new Date();
        if (diff <= 0) {
          clearInterval(iv);
          onStart();
        } else {
          const m = Math.floor(diff/60000), s = Math.floor((diff%60000)/1000);
          document.getElementById("countdown").textContent = `${m}m ${s}s`;
        }
      }, 500);
    }

    // handle verifying exam ID
    document.getElementById("verifyExam").addEventListener("submit", async e => {
    e.preventDefault();
    const examid = +document.getElementById("examid").value;

    const metaResp = await fetch("/get-exam-meta/", {
        method: "POST",
        headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": csrftoken
        },
        body: JSON.stringify({
        examid,
        email: "{{ email }}"       // pass the template-injected user email
        })
    });

    if (metaResp.status === 403) {
        // already attempted
        return showMessage("You have already attempted this exam.");
    }
    if (!metaResp.ok) {
        return showMessage("Exam not found or already ended.");
    }

    const meta = await metaResp.json();
      const now       = new Date();
      const startDate = new Date(`${meta.startDate}T${meta.startTime}`);
      const endDate   = new Date(`${meta.startDate}T${meta.endTime}`);

      if (now > endDate) {
        return showMessage("This exam has already ended.");
      }

      // initialize state
      const state = {
        examid,
        questions:    null,
        numberOfQs:   meta.numberOfQuestions,
        startTimeISO: startDate.toISOString(),
        endTimeISO:   endDate.toISOString(),
        currentIndex: 0,
        answers:      Array(meta.numberOfQuestions).fill(null),
        startedAtISO: null
      };
      persistState(state);

      if (now < startDate) {
        return showCountdown(startDate, () => startExam(state));
      }
      startExam(state);
    });

    // main exam runner
    async function startExam(initialState) {
      let state = restoreState();

      // first time: load questions + mark startedAt
      if (!state.questions) {
        const resp = await fetch("/load-exam/", {
          method:"POST",
          headers:{
            "Content-Type":"application/json",
            "X-CSRFToken":csrftoken
          },
          body: JSON.stringify({ examid: initialState.examid })
        });
        const js = await resp.json();
        state.questions    = js.examquestions;
        state.startedAtISO = new Date().toISOString();
        persistState(state);
      }

      const qs     = state.questions;
      const numQ   = state.numberOfQs;
      const endD   = new Date(state.endTimeISO);
      const startTs= new Date(state.startedAtISO).getTime();

      // Remaining-time updater
      let timerInterval = setInterval(() => {
        const diff = endD - new Date();
        if (diff < 0) diff = 0;
        const m = Math.floor(diff/60000).toString().padStart(2,"0");
        const s = Math.floor((diff%60000)/1000).toString().padStart(2,"0");
        document.getElementById("timer").textContent = `Remaining: ${m}:${s}`;
      }, 1000);

      // auto-submit on time up
      const timeoutId = setTimeout(() => {
        doSubmit(state);
        showMessage("Time is up!");
        clearInterval(timerInterval);
        setTimeout(()=>location.reload(), 5000);
      }, endD - new Date());

      // render question
      function renderQuestion() {
        const i = state.currentIndex;
        const q = qs[i];
        document.querySelector(".exampanel").innerHTML = `
          <div id="timer">Remaining: --:--</div>
          <h4>Question ${i+1} of ${numQ}</h4>
          <p>${q.question}</p>
          ${[1,2,3,4].map(n => {
            const sel = state.answers[i]===n;
            const cls = ['opt', sel?'selected':''].filter(Boolean).join(" ");
            return `<button class="${cls}" data-choice="${n}">${q['option'+n]}</button>`;
          }).join("<br>")}
          <br>
          <button id="prev" ${i===0?'disabled':''}>Previous</button>
          <button id="next">${i+1===numQ?'Submit':'Next'}</button>
        `;

        // attach handlers
        document.querySelectorAll(".opt").forEach(btn=>{
          btn.onclick = () => {
            state.answers[i] = +btn.dataset.choice;
            persistState(state);
            renderQuestion();
          };
        });
        document.getElementById("prev").onclick = () => {
          state.currentIndex = i-1;
          persistState(state);
          renderQuestion();
        };
        document.getElementById("next").onclick = () => {
          if (i+1===numQ) return doSubmit(state);
          state.currentIndex = i+1;
          persistState(state);
          renderQuestion();
        };
      }

      renderQuestion();

      // final submit
      async function doSubmit(st) {
        clearTimeout(timeoutId);
        clearInterval(timerInterval);
        clearState();
        const payload = {
          examid: st.examid,
          email: "{{ email }}",
          timeTakenSeconds: Math.floor((Date.now()-startTs)/1000),
          responses: st.questions.map((q,idx)=>({
            questionnumber: q.questionnumber,
            selectedOption: st.answers[idx]||0,
            timestamp:      new Date().toISOString()
          }))
        };
        await fetch("/submit-exam/", {
          method:"POST",
          headers:{
            "Content-Type":"application/json",
            "X-CSRFToken":csrftoken
          },
          body: JSON.stringify(payload)
        });
        showMessage("Exam completed! Thank you.");
      }
    }

    // on load: if mid-exam, resume
    window.addEventListener("DOMContentLoaded", ()=>{
      const st = restoreState();
      if (st && st.questions) {
        startExam(st);
      }
    });
  </script>
</body>
</html>